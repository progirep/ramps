#include "mdp.hpp"
#include <fstream>
#include <iostream>
#include <sstream>
#include <map>
#include <list>

/**
 * @brief Reads an MDP from the three types of files generated by the Prism model checker
 * @param the file name without the suffix
 */
MDP::MDP(std::string baseFilename) {

    // Read state file
    {
        std::ifstream stateFile(baseFilename+".sta");
        if (stateFile.fail()) {
            std::cerr << "Error: Could not open state file " << baseFilename+".sta" << std::endl;
        }
        std::string labelLine;
        std::getline(stateFile,labelLine);
        std::string dataLine;
        while (std::getline(stateFile,dataLine)) {
            auto separator = dataLine.find(":");
            if (separator==std::string::npos) {
                throw "Error in state file: expected a ':' in a data line.";
            }
            std::istringstream isStateNumber(dataLine.substr(0,separator));
            unsigned int stateNr;
            isStateNumber >> stateNr;
            if (isStateNumber.fail()) {
                throw "Error in state file: Could not read state number.";
            }
            if (stateNr != states.size()) {
                std::ostringstream error;
                error << "Error in state file: Illegal state number in line '" << dataLine << "'";
                throw error.str();
            }
            states.push_back(MDPState(dataLine.substr(separator+1,std::string::npos)));
        }
        transitions.resize(states.size());
    }

    // Read label file / initial state
    {
        initialState = (unsigned int)-1;
        std::ifstream labelFile(baseFilename+".lab");
        if (labelFile.fail()) {
            std::cerr << "Error: Could not open label file " << baseFilename+".lab" << std::endl;
        }
        std::string labelLine;
        std::getline(labelFile,labelLine);
        if (labelLine.substr(0,9)!="0=\"init\" ") {
            throw "Error: Unexpected first line in the label line.";
        }
        std::string dataLine;
        while (std::getline(labelFile,dataLine)) {
            auto separator = dataLine.find(": ");
            if (separator==std::string::npos) {
                throw "Error in label file: expected a ':' in a data line.";
            }
            std::istringstream isStateNumber(dataLine.substr(0,separator));
            unsigned int stateNr;
            isStateNumber >> stateNr;
            if (isStateNumber.fail()) {
                throw "Error in label file: Could not read state number.";
            }
            std::istringstream labelTypes(dataLine.substr(separator+2,std::string::npos));
            int labelType;
            while (labelTypes >> labelType) {
                if (labelType==0) {
                    if (initialState==(unsigned int)-1)
                        initialState = stateNr;
                    else
                        throw "More than one initial state found.";
                }
            }
            if (labelTypes.bad()) {
                std::ostringstream error;
                error << "Illegal label file line:\n" << dataLine;
                throw error.str();
            }
        }
    }

    // Read transitions
    {
        std::ifstream transitionsFile(baseFilename+".tra");
        if (transitionsFile.fail()) {
            std::cerr << "Error: Could not open label file " << baseFilename+".tra" << std::endl;
        }
        std::string numbersLine;
        std::getline(transitionsFile,numbersLine);
        unsigned int nofStates;
        unsigned int nofTransitions;
        unsigned int nofTransitionEdges;
        std::istringstream isNumbersLine;
        isNumbersLine >> nofStates;
        isNumbersLine >> nofTransitions;
        isNumbersLine >> nofTransitionEdges;
        if (isNumbersLine.bad()) throw "Illegal numbers line in the transitions file.";

        std::string dataLine;
        MDPTransition *lastTransition = NULL;
        unsigned int lastTransitionStartingState = (unsigned int)-1;
        unsigned int lastTransitionNumber = (unsigned int)-1;
        while (std::getline(transitionsFile,dataLine)) {

            // Split the line into pieces
            std::istringstream isTransitionLine(dataLine);
            unsigned int stateNr;
            unsigned int transitionNumber;
            unsigned int target;
            double probability;
            std::string labelName;
            isTransitionLine >> stateNr;
            isTransitionLine >> transitionNumber;
            isTransitionLine >> target;
            isTransitionLine >> probability;
            isTransitionLine >> labelName;
            if (isTransitionLine.fail()) {
                labelName = "";
            }
            std::string rest;
            isTransitionLine >> rest;
            if (!isTransitionLine.fail()) {
                std::cerr << rest;
                throw "Error reading transition file line: line is too long.";
            }

            // New transition needed?
            if ((lastTransitionStartingState!=stateNr) || (transitionNumber != lastTransitionNumber)) {
                // Allocate new transition
                if (transitionNumber!=transitions[stateNr].size()) throw "Error in transition number.";
                transitions[stateNr].push_back(MDPTransition());
                lastTransition = &(transitions[stateNr].back());
                lastTransitionStartingState = stateNr;
                lastTransitionNumber = transitionNumber;

                // Check if there is a label....
                if (labelName!="") {
                    // Old action?
                    for (unsigned int i=0;i<actions.size();i++) {
                        if (actions[i]==labelName) lastTransition->action = i;
                    }
                    // New action?
                    if (lastTransition->action==-1) {
                        lastTransition->action = actions.size();
                        actions.push_back(labelName);
                    }
                }
            }
        }
    }
}


/**
 * @brief Constructor for a ParityMDP that is the product of an MDP and a Parity (word) automaton. The latter
 *        is assumed to have self-loops for all non-listed actions.
 * @param the parity automaton file name
 * @param the non-parity mdp
 */
ParityMDP::ParityMDP(std::string parityFilename, const MDP &baseMDP) {

    // Copy basic info
    actions = baseMDP.actions;

    // Read parity automaton
    std::ifstream inFile(parityFilename);
    // for (auto it : baseMDP.actions) {
    //     std::cout << it << "\n";
    // }

    // Parse color list
    std::vector<unsigned int> parityColors;
    {
        std::string colorLine;
        std::getline(inFile,colorLine);
        std::istringstream is(colorLine);
        do {
            unsigned int color;
            is >> color;
            if (!(is.eof())) {
                parityColors.push_back(color);
            }
        } while (!is.fail());
        if (is.bad()) throw "Error reading color line in Parity automaton";
    }

    // Parse transitions
    std::map<std::pair<unsigned int, unsigned int>,unsigned int> parityTransitions;
    std::string data;
    while (std::getline(inFile,data)) {
        if (data.length()>0) {
            unsigned int from;
            std::string label;
            unsigned int to;
            std::istringstream is(data);
            is >> from;
            if (is.fail()) {
                std::ostringstream err;
                err << "Error: Not enough elements in parity automaton line (1): '" << data << "'";
                throw err.str();
            }
            is >> label;
            if (is.fail()) {
                std::ostringstream err;
                err << "Error: Not enough elements in parity automaton line (2): '" << data << "'";
                throw err.str();
            }
            is >> to;
            if (is.bad()) throw "Error: Illegal parity automaton line";

            int numberOfAction = -1;
            for (unsigned int i=0;i<actions.size();i++) {
                if (actions[i]==label) numberOfAction = i;
            }
            if (numberOfAction==-1) {
                std::ostringstream os;
                os << "Error: Did not find '" << label << "' as action in the MDP.";
                throw os.str();
            }
            std::pair<unsigned int, unsigned int> data(from,numberOfAction);
            if (parityTransitions.count(data)>0) throw "Error: The parity automaton is non-deterministic.";
            parityTransitions[data] = to;
        }
    }

    // Build product between the MDP and the parity automaton:
    // 1. Initialize TODO list
    struct TODOTuple {
        unsigned int productState;
        unsigned int mdpState;
        unsigned int parityState;
        TODOTuple(unsigned int pros, unsigned int mdps, unsigned int pars) : productState(pros), mdpState(mdps), parityState(pars) {}
    };
    std::list<TODOTuple> todo;
    std::map<std::pair<unsigned int /*mdpState*/, unsigned int /*parityState*/>, unsigned int /*productState*/> stateMapper;
    todo.push_back(TODOTuple(0,baseMDP.initialState,0));
    stateMapper[std::pair<unsigned int, unsigned int>(baseMDP.initialState,0)] = 0;
    colors.push_back(parityColors[0]);
    nofColors = parityColors[0];
    initialState = 0;
    nofColors = 0; // Will be increased during execution

    // 2. Process TODO list
    while (todo.size()>0) {

        TODOTuple thisItem = todo.front();
        todo.pop_front();

        // Iterate through the transitions
        for (auto &tran : baseMDP.transitions[thisItem.mdpState]) {
            MDPTransition targetTransition;
            targetTransition.action = tran.action;

            std::pair<unsigned int /*parityState*/, unsigned int /*action*/> parityEdge(thisItem.parityState,tran.action);
            unsigned int parityTargetState;
            if (parityTransitions.count(parityEdge)==0) {
                parityTargetState = thisItem.parityState;
            } else {
                parityTargetState = parityTransitions[parityEdge];
            }

            for (auto &edge : tran.edges) {

                std::pair<unsigned int /*mdpState*/, unsigned int /*parityState*/> target(edge.second,parityTargetState);
                if (stateMapper.count(target)==0) {
                    stateMapper[target] = states.size();
                    std::ostringstream stateName;
                    stateName << baseMDP.states[edge.second].label;
                    stateName << "," << parityTargetState;
                    states.push_back(MDPState(stateName.str()));
                    colors.push_back(parityColors[parityTargetState]);
                    nofColors = std::max(nofColors,parityColors[parityTargetState]);
                }

                targetTransition.edges.push_back(std::pair<double,unsigned int>(edge.first,stateMapper[target]));
            }
        }
    }
}
