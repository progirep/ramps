#include "mdp.hpp"
#include <fstream>
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <list>

/**
 * @brief Reads an MDP from the three types of files generated by the Prism model checker
 * @param the file name without the suffix
 */
MDP::MDP(std::string baseFilename) {

    // Read state file
    {
        std::ifstream stateFile(baseFilename+".sta");
        if (stateFile.fail()) {
            std::cerr << "Error: Could not open state file " << baseFilename+".sta" << std::endl;
            throw 1;
        }
        std::string labelLine;
        std::getline(stateFile,labelLine);
        if (stateFile.fail()) throw "Error: Empty label file.";
        {
            // Parse label line
            if (labelLine.at(0)!='(') throw "Illegal MDP state name pattern: no opening brace";
            if (labelLine.at(labelLine.length()-1)!=')') throw "Illegal MDP state name pattern: no closing brace";
            labelLine = labelLine.substr(1,labelLine.size()-2);
            for (auto a = labelLine.find(","); a != std::string::npos;) {
                // std::cerr << labelLine << "\n";
                labelComponents.push_back(labelLine.substr(0,a));
                labelLine = labelLine.substr(a+1,std::string::npos);
                a = labelLine.find(",");
            }
            labelComponents.push_back(labelLine);
        }

        std::string dataLine;
        while (std::getline(stateFile,dataLine)) {
            if (dataLine.length()>0) {
                auto separator = dataLine.find(":");
                if (separator==std::string::npos) {
                    throw "Error in state file: expected a ':' in a data line.";
                }
                std::istringstream isStateNumber(dataLine.substr(0,separator));
                unsigned int stateNr;
                isStateNumber >> stateNr;
                if (isStateNumber.fail()) {
                    throw "Error in state file: Could not read state number.";
                }
                if (stateNr != states.size()) {
                    std::ostringstream error;
                    error << "Error in state file: Illegal state number in line '" << dataLine << "'";
                    throw error.str();
                }

                // Parse the state label
                std::vector<std::string> labelParts;
                std::string label = dataLine.substr(separator+1,std::string::npos);
                if (label.at(0)!='(') throw "Illegal MDP state name: no opening brace";
                if (label.at(label.length()-1)!=')') throw "Illegal MDP state name: no closing brace";
                label = label.substr(1,label.size()-2);
                for (auto a = label.find(","); a != std::string::npos;) {
                    labelParts.push_back(label.substr(0,a));
                    label = label.substr(a+1,std::string::npos);
                    a = label.find(",");
                }
                labelParts.push_back(label);
                states.push_back(MDPState(labelParts));
            }
        }
        transitions.resize(states.size());
    }

    // Read label file / initial state
    {
        initialState = (unsigned int)-1;
        std::ifstream labelFile(baseFilename+".lab");
        if (labelFile.fail()) {
            std::cerr << "Error: Could not open label file " << baseFilename+".lab" << std::endl;
            throw 1;
        }
        std::string labelLine;
        std::getline(labelFile,labelLine);
        if (labelLine.substr(0,9)!="0=\"init\" ") {
            throw "Error: Unexpected first line in the label line.";
        }
        std::string dataLine;
        while (std::getline(labelFile,dataLine)) {
            if (dataLine.length()>0) {
                auto separator = dataLine.find(": ");
                if (separator==std::string::npos) {
                    throw "Error in label file: expected a ':' in a data line.";
                }
                std::istringstream isStateNumber(dataLine.substr(0,separator));
                unsigned int stateNr;
                isStateNumber >> stateNr;
                if (isStateNumber.fail()) {
                    throw "Error in label file: Could not read state number.";
                }
                std::istringstream labelTypes(dataLine.substr(separator+2,std::string::npos));
                int labelType;
                while (labelTypes >> labelType) {
                    if (labelType==0) {
                        if (initialState==(unsigned int)-1)
                            initialState = stateNr;
                        else
                            throw "More than one initial state found.";
                    }
                }
                if (labelTypes.bad()) {
                    std::ostringstream error;
                    error << "Illegal label file line:\n" << dataLine;
                    throw error.str();
                }
            }
        }
    }

    // Read transitions
    {
        std::ifstream transitionsFile(baseFilename+".tra");
        if (transitionsFile.fail()) {
            std::cerr << "Error: Could not open label file " << baseFilename+".tra" << std::endl;
            throw 1;
        }
        std::string numbersLine;
        std::getline(transitionsFile,numbersLine);
        unsigned int nofStates;
        unsigned int nofTransitions;
        unsigned int nofTransitionEdges;
        std::istringstream isNumbersLine;
        isNumbersLine >> nofStates;
        isNumbersLine >> nofTransitions;
        isNumbersLine >> nofTransitionEdges;
        if (isNumbersLine.bad()) throw "Illegal numbers line in the transitions file.";

        std::string dataLine;
        MDPTransition *lastTransition = NULL;
        unsigned int lastTransitionStartingState = (unsigned int)-1;
        unsigned int lastTransitionNumber = (unsigned int)-1;
        while (std::getline(transitionsFile,dataLine)) {
            if (dataLine.length()>0) {

                // Split the line into pieces
                std::istringstream isTransitionLine(dataLine);
                unsigned int stateNr;
                unsigned int transitionNumber;
                unsigned int target;
                double probability;
                std::string labelName;
                isTransitionLine >> stateNr;
                if (isTransitionLine.fail()) throw "Error: Too short line in the transition file (1)";
                isTransitionLine >> transitionNumber;
                if (isTransitionLine.fail()) throw "Error: Too short line in the transition file (2)";
                isTransitionLine >> target;
                if (isTransitionLine.fail()) throw "Error: Too short line in the transition file (3)";
                isTransitionLine >> probability;
                if (isTransitionLine.fail()) throw "Error: Too short line in the transition file (4)";
                isTransitionLine >> labelName;
                if (isTransitionLine.fail()) {
                    labelName = "";
                }
                std::string rest;
                isTransitionLine >> rest;
                if (!isTransitionLine.fail()) {
                    throw "Error reading transition file line: line is too long.";
                }

                // New transition needed?
                if ((lastTransitionStartingState!=stateNr) || (transitionNumber != lastTransitionNumber)) {

                    // Allocate new transition
                    if (transitionNumber!=transitions[stateNr].size()) throw "Error in transition number.";
                    transitions[stateNr].push_back(MDPTransition());
                    lastTransition = &(transitions[stateNr].back());
                    lastTransitionStartingState = stateNr;
                    lastTransitionNumber = transitionNumber;

                    // Check if there is a label....
                    if (labelName!="") {
                        // Old action?
                        for (unsigned int i=0;i<actions.size();i++) {
                            if (actions[i]==labelName) lastTransition->action = i;
                        }
                        // New action?
                        if (lastTransition->action==-1) {
                            lastTransition->action = actions.size();
                            actions.push_back(labelName);
                        }
                    }
                }

                // Add an edge to the transition
                lastTransition->edges.push_back(std::pair<double, unsigned int>(probability,target));
            }
        }
    }

    // Check probabilities
    for (unsigned int i=0;i<transitions.size();i++) {
        auto &trA = transitions[i];
        for (unsigned int j=0;j<trA.size();j++) {
            auto &trB = trA[j];
            double sum = 0.0;
            for (auto &dat : trB.edges) {
                sum += dat.first;
            }
            if ((sum<0.999) || (sum>1.001)) {
                std::ostringstream err;
                err << "Sum of probabilities for transition " << j << " from state " << i << " adds up to probability " << sum;
                throw err.str();
            }
        }
    }

    // Check the strongly connectedness of the MDP
    std::list<unsigned int> todo;
    std::set<unsigned int> done;
    todo.push_back(initialState);
    done.insert(initialState);
    while (todo.size()>0) {
        unsigned int thisOne = todo.front();
        todo.pop_front();
        for (auto &t : transitions[thisOne]) {
            for (auto &e : t.edges) {
                if (done.count(e.second)==0) {
                    todo.push_back(e.second);
                    done.insert(e.second);
                }
            }
        }
    }
    if (done.size()!=states.size()) {
        std::cerr << "Warning: Found " << states.size()-done.size() << " unreadable states in the MDP!\n";
        std::cerr << "Examples state numbers are:";
        unsigned int statesPrinted = 0;
        for (unsigned int i=0;i<states.size();i++) {
            if (done.count(i)==0) {
                if (statesPrinted<100) {
                    std::cerr << " " << i;
                    statesPrinted++;
                }
            }
        }
        std::cerr << std::endl;
    }


}


/**
 * @brief Constructor for a ParityMDP that is the product of an MDP and a Parity (word) automaton. The latter
 *        is assumed to have self-loops for all non-listed actions.
 * @param the parity automaton file name
 * @param the non-parity mdp
 */
ParityMDP::ParityMDP(std::string parityFilename, const MDP &baseMDP) {

    // Copy basic info
    actions = baseMDP.actions;

    // Read parity automaton
    std::ifstream inFile(parityFilename);
    if (inFile.fail()) {
        std::ostringstream error;
        error << "Cannot open parity automaton file '" << parityFilename << "'.";
        throw error.str();
    }
    // for (auto it : baseMDP.actions) {
    //     std::cout << it << "\n";
    // }

    // Parse color list
    std::vector<unsigned int> parityColors;
    {
        std::string colorLine;
        std::getline(inFile,colorLine);
        std::istringstream is(colorLine);
        while (!(is >> std::ws).fail()) {
            unsigned int color;
            is >> color;
            parityColors.push_back(color);
            if (is.bad()) throw "Error reading color line in Parity automaton";
        };
    }

    // Parse transitions
    std::map<std::pair<unsigned int, std::string>,unsigned int> parityTransitions;
    std::string data;
    while (std::getline(inFile,data)) {
        if (data.length()>0) {
            unsigned int from;
            std::string label;
            unsigned int to;
            std::istringstream is(data);
            is >> from;
            if (is.fail()) {
                std::ostringstream err;
                err << "Error: Not enough elements in parity automaton line (1): '" << data << "'";
                throw err.str();
            }
            is >> label;
            if (is.fail()) {
                std::ostringstream err;
                err << "Error: Not enough elements in parity automaton line (2): '" << data << "'";
                throw err.str();
            }
            is >> to;
            if (is.bad()) throw "Error: Illegal parity automaton line";
            is >> std::ws;
            if (!is.eof()) throw "Error: A parity automaton line is too long";

            std::pair<unsigned int, std::string> data(from,label);
            if (parityTransitions.count(data)>0) throw "Error: The parity automaton is non-deterministic.";
            parityTransitions[data] = to;
        }
    }

    // Build product between the MDP and the parity automaton:
    // 1. Initialize TODO list
    struct TODOTuple {
        unsigned int productState;
        unsigned int mdpState;
        unsigned int parityState;
        TODOTuple(unsigned int pros, unsigned int mdps, unsigned int pars) : productState(pros), mdpState(mdps), parityState(pars) {}
    };
    std::list<TODOTuple> todo;
    std::map<std::pair<unsigned int /*mdpState*/, unsigned int /*parityState*/>, unsigned int /*productState*/> stateMapper;
    todo.push_back(TODOTuple(0,baseMDP.initialState,0));
    stateMapper[std::pair<unsigned int, unsigned int>(baseMDP.initialState,0)] = 0;
    colors.push_back(parityColors[0]);
    {
        std::vector<std::string> stateLabel = baseMDP.states[baseMDP.initialState].label;
        stateLabel.push_back("0");
        states.push_back(MDPState(stateLabel));
    }
    nofColors = parityColors[0];
    initialState = 0;
    nofColors = 0; // Will be increased during execution

    // 2. Process TODO list
    while (todo.size()>0) {

        TODOTuple thisItem = todo.front();
        todo.pop_front();
        //std::cerr << "todo"<< thisItem.mdpState << "," << thisItem.parityState << "," << thisItem.productState << std::endl;
        while (transitions.size()<=thisItem.productState) transitions.push_back(std::vector<MDPTransition>());
        toNonParityMDPMapper[thisItem.productState] = thisItem.mdpState;

        // Iterate through the transitions
        for (auto &tran : baseMDP.transitions[thisItem.mdpState]) {
            MDPTransition targetTransition;
            targetTransition.action = tran.action;

            // Where does the parity
            unsigned int parityTargetState;
            if (tran.action!=-1) {
                std::pair<unsigned int /*parityState*/, std::string /*action*/> parityEdge(thisItem.parityState,actions[tran.action]);
                if (parityTransitions.count(parityEdge)==0) {
                    parityTargetState = thisItem.parityState;
                } else {
                    parityTargetState = parityTransitions[parityEdge];
                }
            } else {
                parityTargetState = thisItem.parityState;
            }

            // Iterate over the transitions
            for (auto &edge : tran.edges) {

                // Check if we have a new target parity state
                unsigned int edgeParityTargetState = parityTargetState;

                // If there is a '=' in the parity action name, then this refers to the state component
                for (auto &a : parityTransitions) {
                    if (a.first.first == thisItem.parityState) {
                        if (a.first.second.find("=")!=std::string::npos) {

                            // This is a compound action -> interpret appropriately
                            std::string varName = a.first.second.substr(0,a.first.second.find("="));
                            std::string varValue = a.first.second.substr(a.first.second.find("=")+1,std::string::npos);

                            // Find state component
                            int index = -1;
                            for (unsigned int i=0;i<baseMDP.labelComponents.size();i++) {
                                if (baseMDP.labelComponents[i]==varName) {
                                    index = i;
                                }
                            }
                            if (index==-1) {
                                std::ostringstream err; err << "Did not find key '" << varName << "'";
                                throw err.str();
                            }
                            if (varValue==baseMDP.states[edge.second].label[index]) {
                                //std::cerr << "Found a complex edge match\n";
                                edgeParityTargetState = a.second;
                                //std::cout << "Dest: " << a.second << std::endl;
                            }
                        } else {
                            throw "Action synchronization is currently not supported.";
                        }
                    }
                }

                std::pair<unsigned int /*mdpState*/, unsigned int /*parityState*/> target(edge.second,edgeParityTargetState);
                if (stateMapper.count(target)==0) {
                    stateMapper[target] = states.size();
                    todo.push_back(TODOTuple(states.size(),edge.second,edgeParityTargetState));
                    std::vector<std::string> stateLabel = baseMDP.states[edge.second].label;
                    // std::cerr << "Prod: " << baseMDP.states[edge.second].label.size() << std::endl;
                    std::ostringstream parityTargetString; parityTargetString << edgeParityTargetState;
                    stateLabel.push_back(parityTargetString.str());
                    states.push_back(MDPState(stateLabel));
                    colors.push_back(parityColors.at(edgeParityTargetState));
                    nofColors = std::max(nofColors,parityColors[edgeParityTargetState]);
                }

                targetTransition.edges.push_back(std::pair<double,unsigned int>(edge.first,stateMapper.at(target)));
            }

            transitions[thisItem.productState].push_back(targetTransition);
        }
    }
}

/**
 * @brief Draws a parity MDP as DOT file.
 * @param output The output stream.
 */
void ParityMDP::dumpDot(std::ostream &output) const {
    output << "digraph dotFile {\n";
    for (unsigned int i=0;i<states.size();i++) {
        output << "  s" << i << "[label=\"(";
        bool first = true;
        for (auto a : states.at(i).label) {
            if (first) {
                first = false;
            } else {
                output << ",";
            }
            output << a;
        }
        output << ")\",shape=rectangle];\n";
    }
    unsigned int edgeID = 0;
    for (unsigned int i=0;i<transitions.size();i++) {
        for (unsigned int j=0;j<transitions[i].size();j++) {
            output << "  e" << edgeID << "[label=\"\",size=0.05,fixedsize=true,shape=point];\n";
            output << "  s" << i << " -> e" << edgeID << "[label=\"";
            if (transitions[i][j].action!=-1) output << actions[transitions[i][j].action];
            output << "\",dir=none];\n";
            for (auto &edge : transitions[i][j].edges) {
                output << "  e" << edgeID << " -> s" << edge.second << "[label=\"" << edge.first << "\"];\n";
            }
            edgeID++;
        }
    }
    output << "}\n";
}
